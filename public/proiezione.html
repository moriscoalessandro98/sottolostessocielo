<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Proiezione da soffitto</title>
<style>
html, body {
  margin: 0; padding: 0;
  width: 100%; height: 100%;
  overflow: hidden;
  background: #000;
  font-family: "Georgia", serif;
  color: #fff;
}
canvas { 
  position: fixed; 
  inset: 0; 
  z-index: 0; 
  display:block;
}
</style>
</head>
<body>
<canvas id="sky"></canvas>

<script>
const canvas = document.getElementById("sky");
const ctx = canvas.getContext("2d");
let w, h;
function resize() { w = canvas.width = window.innerWidth; h = canvas.height = window.innerHeight; }
window.addEventListener("resize", resize);
resize();

// ---------- STELLE ---------- //
const STAR_COUNT = 500;
const stars = [];
for(let i=0;i<STAR_COUNT;i++){
  stars.push({
    x: Math.random()*w,
    y: Math.random()*h,
    r: Math.random()*1.2+0.2,
    angle: Math.random()*Math.PI*2,
    speed: Math.random()*0.0005 + 0.0001
  });
}

// ---------- COMETE ---------- //
const comets = [];
function spawnComet() {
  if(Math.random()<0.005 && comets.length<3){
    comets.push({
      x: Math.random()*w,
      y: Math.random()*h*0.5,
      vx: Math.random()*4+2,
      vy: Math.random()*2+1,
      life: 0,
      maxLife: Math.random()*60+60
    });
  }
}

// ---------- SOGNI ---------- //
let dreams = [];
let activeDreams = [];
let dreamIndex = 0;
let lastDreamId = null;

async function fetchDreams(){
  try{
    const res = await fetch("/api/dreams");
    if(res.ok){
      const data = await res.json();
      dreams = shuffle(data.map(d=>d));
      dreamIndex = 0;
    }
  } catch{}
}

function shuffle(array){
  for(let i=array.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [array[i], array[j]]=[array[j], array[i]];
  }
  return array;
}

class Dream {
  constructor(text, x, y){
    this.text = text;
    this.x = x;
    this.y = y;
    this.opacity = 0;
    this.timer = 0;
    this.visible = true;
  }
  update(dt){
    this.timer += dt;
    if(this.timer < 60){ // fade-in
      this.opacity += 0.015;
      if(this.opacity>0.9) this.opacity=0.9;
    } else if(this.timer > 400){ // fade-out
      this.opacity -= 0.01;
      if(this.opacity<=0){
        this.opacity=0;
        this.visible=false;
      }
    }
  }
  draw(){
    if(this.opacity>0){
      ctx.globalAlpha = this.opacity;
      ctx.font = "22px Georgia";
      ctx.fillStyle = "#fff";
      ctx.textAlign = "center";
      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.rotate(-0.03); // lieve inclinazione
      ctx.fillText(this.text, 0, 0);
      ctx.restore();
      ctx.globalAlpha = 1;
    }
  }
}

// ---------- POSIZIONE NON SOVRAPPOSITIVA ---------- //
function getNonOverlappingPosition(){
  let x, y, tries=0;
  do{
    x = Math.random()*w*0.8 + w*0.1;
    y = Math.random()*h*0.4 + h*0.1; // alto sul soffitto
    let tooClose = activeDreams.some(d=>Math.hypot(d.x - x, d.y - y)<250);
    if(!tooClose) break;
    tries++;
  } while(tries<20);
  return {x,y};
}

// ---------- LOGICA SOGNI ---------- //
let lastSpawnTime = 0;
function manageDreams(dt){
  lastSpawnTime += dt;
  if(lastSpawnTime > 300 && dreams.length>0){
    let dream;
    let attempts = 0;
    do{
      dream = dreams[dreamIndex % dreams.length];
      dreamIndex++;
      attempts++;
    } while(dream._id === lastDreamId && attempts < dreams.length);

    lastDreamId = dream._id;
    const {x,y} = getNonOverlappingPosition();
    activeDreams.push(new Dream(dream.dream, x, y));
    lastSpawnTime = 0;
  }
  activeDreams.forEach(d=>d.update(dt));
  activeDreams = activeDreams.filter(d=>d.visible);
}

// ---------- PROSPETTIVA ---------- //
function perspective(x, y){
  const depth = h - y;
  const scale = 0.3 + 0.7*(depth/h);
  return {
    x: w/2 + (x - w/2)*scale,
    y: y*0.6 + h*0.2,
    r: scale
  };
}

// ---------- ANIMAZIONE ---------- //
let lastTime = 0;
function animate(time=0){
  const dt = (time - lastTime)/16.666;
  lastTime=time;

  ctx.fillStyle = "rgba(0,0,0,0.9)";
  ctx.fillRect(0,0,w,h);

  // oscillazione lieve per effetto proiettore
  const tilt = 0.003 * Math.sin(time/1000);
  ctx.save();
  ctx.translate(w/2, h/2);
  ctx.rotate(tilt);
  ctx.translate(-w/2, -h/2);

  // stelle
  stars.forEach(s=>{
    s.angle += s.speed*dt;
    const {x: cx, y: cy, r} = perspective(s.x, s.y);
    ctx.globalAlpha = 0.6;
    ctx.fillStyle="#fff";
    ctx.shadowBlur = 8;
    ctx.shadowColor = "white";
    ctx.beginPath();
    ctx.arc(cx,cy,r,0,Math.PI*2);
    ctx.fill();
    ctx.shadowBlur = 0;
  });
  ctx.globalAlpha = 1;

  // comete
  spawnComet();
  comets.forEach((c,i)=>{
    ctx.strokeStyle = "rgba(255,255,255,0.8)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(c.x,c.y);
    ctx.lineTo(c.x - c.vx*4, c.y - c.vy*4);
    ctx.stroke();
    c.x += c.vx; c.y += c.vy;
    c.life++;
    if(c.life>c.maxLife) comets.splice(i,1);
  });

  ctx.restore(); // reset rotazione

  // sogni
  manageDreams(dt);
  activeDreams.forEach(d=>d.draw());

  requestAnimationFrame(animate);
}

animate();
fetchDreams();
setInterval(fetchDreams,8000);

</script>
</body>
</html>
