<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Proiezione dei sogni</title>
<style>
html, body {
  margin: 0; padding: 0;
  width: 100%; height: 100%;
  overflow: hidden;
  background: #000;
  font-family: "Georgia", serif;
  color: #fff;
}
canvas { 
  position: fixed; 
  inset: 0; 
  z-index: 0; 
  display:block;
}
</style>
</head>
<body>
<canvas id="sky"></canvas>

<script>
const canvas = document.getElementById("sky");
const ctx = canvas.getContext("2d");
let w, h;

function resize() {
  w = canvas.width = window.innerWidth;
  h = canvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

// ---------- STELLE ---------- //
const STAR_COUNT = 500;
const stars = [];
for(let i=0;i<STAR_COUNT;i++){
  stars.push({
    x: Math.random()*w,
    y: Math.random()*h,
    r: Math.random()*1.2+0.2,
    angle: Math.random()*Math.PI*2,
    speed: Math.random()*0.0005 + 0.0001
  });
}

// ---------- COMETE ---------- //
const comets = [];
function spawnComet() {
  if(Math.random()<0.005 && comets.length<3){
    comets.push({
      x: Math.random()*w,
      y: Math.random()*h*0.5,
      vx: Math.random()*4+2,
      vy: Math.random()*2+1,
      life: 0,
      maxLife: Math.random()*60+60
    });
  }
}

// ---------- SOGNI ---------- //
let dreams = [];
let activeDreams = [];
let dreamIndex = 0;
let lastDreamId = null;

async function fetchDreams(){
  try{
    const res = await fetch("/api/dreams");
    if(res.ok){
      const data = await res.json();
      dreams = shuffle(data.map(d=>d));
      dreamIndex = 0;
    }
  } catch{}
}

function shuffle(array){
  for(let i=array.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [array[i], array[j]]=[array[j], array[i]];
  }
  return array;
}

// ---------- CLASSE DREAM MULTILINEA ---------- //
class Dream {
  constructor(text, x, y, maxWidth){
    this.text = text;
    this.x = x;
    this.y = y;
    this.opacity = 0;
    this.timer = 0;
    this.visible = true;
    this.maxWidth = maxWidth;
    this.lines = this.wrapText(text, maxWidth);
    this.lineHeight = 26;
    // Salva dimensioni reali
    this.textWidth = Math.min(maxWidth, Math.max(...this.lines.map(line => ctx.measureText(line).width)));
    this.textHeight = this.lines.length * this.lineHeight;
  }

  wrapText(text, maxWidth){
    const words = text.split(' ');
    const lines = [];
    let line = '';
    words.forEach(word => {
      const testLine = line + (line ? ' ' : '') + word;
      if(ctx.measureText(testLine).width > maxWidth){
        if(line) lines.push(line);
        line = word;
      } else {
        line = testLine;
      }
    });
    if(line) lines.push(line);
    return lines;
  }

  update(dt){
    this.timer += dt;
    if(this.timer < 60){ // fade-in
      this.opacity += 0.015;
      if(this.opacity>0.9) this.opacity=0.9;
    } else if(this.timer > 400){ // fade-out
      this.opacity -= 0.01;
      if(this.opacity<=0){
        this.opacity=0;
        this.visible=false;
      }
    }
  }

  draw(){
    if(this.opacity>0){
      ctx.globalAlpha = this.opacity;
      ctx.font = "22px Georgia";
      ctx.fillStyle = "#fff";
      ctx.textAlign = "center";
      this.lines.forEach((line,i)=>{
        ctx.fillText(line, this.x, this.y + i*this.lineHeight);
      });
      ctx.globalAlpha = 1;
    }
  }
}

// ---------- POSIZIONE SICURA ---------- //
function getSafePosition(text){
  const maxWidth = w * 0.6; // max 60% della larghezza
  const lineHeight = 26;

  // stima numero righe
  const words = text.split(' ');
  let estimatedLines = 1;
  let line = '';
  words.forEach(word => {
    const testLine = line + (line ? ' ' : '') + word;
    if(ctx.measureText(testLine).width > maxWidth){
      if(line) estimatedLines++;
      line = word;
    } else {
      line = testLine;
    }
  });

  const textHeight = estimatedLines * lineHeight;
  const textWidth = Math.min(maxWidth, ctx.measureText(text).width);

  let x, y, tries = 0;
  do {
    x = Math.random() * (w - textWidth - 20) + textWidth/2 + 10;
    y = Math.random() * (h*0.7 - textHeight) + textHeight;

    // distanza minima proporzionale alla dimensione della frase
    const minDist = Math.max(textWidth, textHeight) * 1.5; // moltiplica per 1.5 per spazio extra
    let tooClose = activeDreams.some(d => {
      const dx = Math.abs(d.x - x);
      const dy = Math.abs(d.y - y);
      return dx < (d.textWidth/2 + textWidth/2 + 20) && dy < (d.textHeight/2 + textHeight/2 + 20);
    });

    if(!tooClose) break;
    tries++;
  } while(tries < 100); // piÃ¹ tentativi

  return {x, y, maxWidth};
}

// ---------- LOGICA SOGNI ---------- //
let lastSpawnTime = 0;
function manageDreams(dt){
  lastSpawnTime += dt;
  if(lastSpawnTime > 300 && dreams.length > 0){
    let dream;
    let attempts = 0;
    do {
      dream = dreams[dreamIndex % dreams.length];
      dreamIndex++;
      attempts++;
    } while(dream._id === lastDreamId && attempts < dreams.length);

    lastDreamId = dream._id;
    const {x, y, maxWidth} = getSafePosition(dream.dream);
    activeDreams.push(new Dream(dream.dream, x, y, maxWidth));
    lastSpawnTime = 0;
  }
  activeDreams.forEach(d => d.update(dt));
  activeDreams = activeDreams.filter(d => d.visible);
}

// ---------- ANIMAZIONE ---------- //
let lastTime = 0;
function animate(time=0){
  const dt = (time - lastTime)/16.666;
  lastTime=time;

  // cielo e stelle
  ctx.fillStyle = "rgba(0,0,0,0.05)";
  ctx.fillRect(0,0,w,h);
  stars.forEach(s=>{
    s.angle += s.speed*dt;
    const cx = w/2 + Math.cos(s.angle)*(s.x-w/2) - Math.sin(s.angle)*(s.y-h/2);
    const cy = h/2 + Math.sin(s.angle)*(s.x-w/2) + Math.cos(s.angle)*(s.y-h/2);
    ctx.globalAlpha = 0.6;
    ctx.fillStyle="#fff";
    ctx.beginPath();
    ctx.arc(cx,cy,s.r,0,Math.PI*2);
    ctx.fill();
  });
  ctx.globalAlpha = 1;

  // comete
  spawnComet();
  comets.forEach((c,i)=>{
    ctx.strokeStyle = "rgba(255,255,255,0.8)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(c.x,c.y);
    ctx.lineTo(c.x - c.vx*4, c.y - c.vy*4);
    ctx.stroke();
    c.x += c.vx; c.y += c.vy;
    c.life++;
    if(c.life>c.maxLife) comets.splice(i,1);
  });

  // sogni
  manageDreams(dt);
  activeDreams.forEach(d=>d.draw());

  requestAnimationFrame(animate);
}

animate();
fetchDreams();
setInterval(fetchDreams,8000);
</script>

</body>
</html>
